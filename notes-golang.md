# 数组
## 定义
```golang
var a [3]int                    // 定义长度为3的int型数组, 元素全部为0
var b = [...]int{1, 2, 3}       // 定义长度为3的int型数组, 元素为 1, 2, 3
var c = [...]int{2: 3, 1: 2}    // 定义长度为3的int型数组, 元素为 0, 2, 3
var d = [...]int{1, 2, 4: 5, 6} // 定义长度为6的int型数组, 元素为 1, 2, 0, 0, 5, 6
```
- 数组是**值语义**，传递时复制整个数组
- `[0]int{}` 空数组不占用内存空间

# select
用于 case 一系列 channel 的收发状态，默认情况下会阻塞当前线程和 Goroutine

- 非阻塞收发：当包含 `default` 时，select **不会阻塞**，用于检查所有 case 中是否存在可读写的情况
```golang
select {
case err := <-errCh:
    return err
default:
    return nil
}
```

- 随机执行：当有多个 case 同时就绪，会随机执行其中一个。可以避免顺序执行时后续 case 产生饥饿问题

# defer
- 作用域：在当前函数和方法返回之前
- 倒序执行：多个 defer 按调用顺序倒序执行
- 预定义参数：defer 的传值在 defer 关键字调用时计算

# mutex
互斥锁
```golang
type Mutex struct {
    state int32
    sema  uint32
}
```
![unlock](./picture/golang/mutex_unlock.png)

- 加锁时，如果 Locked = 1（已加锁），满足以下 **自旋条件** 情况下，协程会自选，而非马上阻塞：
  1. 自旋次数足够小，通常为4，即自旋最多4次
  2. CPU核数要大于1，否则自旋没有意义，因为此时不可能有其他协程释放锁
  3. 协程调度机制中的Process数量要大于1，比如使用GOMAXPROCS()将处理器设置为1就不能启用自旋
  4. 协程调度机制中的可运行队列必须为空，否则会延迟协程调度
  5. 当前没有协程进入饥饿（Starvation）状态
- 自选可以让当前协程有机会马上获得锁，避免了协程切换
- 当有协程被唤醒尝试加锁，但是因为有协程自旋抢先获得锁，自己被迫重新阻塞后，就会标记饥饿（Starvation）

# RWMutex
读写互斥锁
```golang
type RWMutex struct {
    w           Mutex  //用于控制多个写锁，获得写锁首先要获取该锁，如果有一个写锁在进行，那么再到来的写锁将会阻塞于此
    writerSem   uint32 //写阻塞等待的信号量，最后一个读者释放锁时会释放信号量
    readerSem   uint32 //读阻塞的协程等待的信号量，持有写锁的协程释放锁后会释放信号量
    readerCount int32  //记录读者个数
    readerWait  int32  //记录写阻塞时读者个数
}
```
## 写锁阻塞写锁
- 写锁需要获取 Mutex，已获取 Mutex 则进入阻塞

## 写锁阻塞读锁
- 写锁将 `readerCount - 2^30 (int32 最大值)`
- 读请求到来进行 `readerCount + 1`，判断负值，知道有写锁，遂阻塞等待
- 写锁释放后， `readerCount + 2^30`，此时恰好是等待释放写锁的`读协程数`

## 读锁阻塞写锁（但写防饥饿）
- 写请求发现 `readerCount != 0`，遂阻塞等待，但会将此时的 `readerWait = readerCount`，表示最多等待当前所有读请求完成，避免`写请求饥饿`
- 后续的读请求到来会：
  - 等待原始读请求完成 `readerWait = 0`
  - 进入写请求，等待写请求完成
  - 继续后续的读请求

# 协程调度 
## 进程、线程、协程
- 进程：独立的栈、堆空间，进程切换只发生于内核态
- 线程：独立的栈，进程内共享堆。上下文切换较进程更轻，但仍**需内核调度**，会发生用户态、内核态切换。
- 协程：
  - 将独立的函数（协程）多路复用到一组线程上
  - 由用户代码控制协程调度，因此协程切换仅发生在用户态，内核不感知
  - 占用内存很小，KB级别，可以创建几十万（线程是 MB）

协程的优势：
1. CPU 优势：避免内核级的频繁切换
2. 性能高：因为切换只发生在用户态，没有系统调用、时钟中断等影响
3. 节约内存：协程只占 KB（但可以伸缩）
4. 开发效率高：协程容易操作

## GMP 调度模型
![GMP](./picture/golang/gmp.webp)
- `P(Prossesor)`：运行 G 的资源实体，通常是 CPU 核心; `M(Machine)`: 工作线程; `G(Goroutine)`
- M0：初始M，用于执行第一个G，后续和普通M作用相同
- G0: 每一个M中固定存在一个G0，进行调度G任务。每当G主动或被动让渡时，M需要切换至G0调度新的G执行 `G->G0->G`
- P 的最大数目(`执行中+自选`)由 `runtime.GOMAXPROCS` 控制

### 调度流程
![SCHE](./picture/golang/gmp_sche.jpeg)
1. 程